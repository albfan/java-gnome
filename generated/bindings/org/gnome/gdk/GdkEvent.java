/*
 * java-gnome, a UI library for writing GTK and GNOME programs from Java!
 *
 * Copyright Â© 2006-2012 Operational Dynamics Consulting, Pty Ltd and Others
 *
 * The code in this file, and the program it is a part of, is made available
 * to you by its authors as open source software: you can redistribute it
 * and/or modify it under the terms of the GNU General Public License version
 * 2 ("GPL") as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GPL for more details.
 *
 * You should have received a copy of the GPL along with this program. If not,
 * see http://www.gnu.org/licenses/. The authors of this program may be
 * contacted through http://java-gnome.sourceforge.net/.
 *
 * Linking this library statically or dynamically with other modules is making
 * a combined work based on this library. Thus, the terms and conditions of
 * the GPL cover the whole combination. As a special exception (the
 * "Classpath Exception"), the copyright holders of this library give you
 * permission to link this library with independent modules to produce an
 * executable, regardless of the license terms of these independent modules,
 * and to copy and distribute the resulting executable under terms of your
 * choice, provided that you also meet, for each linked independent module,
 * the terms and conditions of the license of that module. An independent
 * module is a module which is not derived from or based on this library. If
 * you modify this library, you may extend the Classpath Exception to your
 * version of the library, but you are not obligated to do so. If you do not
 * wish to do so, delete this exception statement from your version.
 */
package org.gnome.gdk;

/*
 * THIS FILE IS GENERATED CODE!
 *
 * To modify its contents or behaviour, either update the generation program,
 * change the information in the source defs file, or implement an override for
 * this class.
 */

import org.freedesktop.bindings.BlacklistedMethodError;
import org.freedesktop.bindings.FIXME;
import org.gnome.gdk.AxisUse;
import org.gnome.gdk.Device;
import org.gnome.gdk.Event;
import org.gnome.gdk.EventType;
import org.gnome.gdk.ModifierType;
import org.gnome.gdk.Plumbing;
import org.gnome.gdk.Screen;
import org.gnome.gdk.ScrollDirection;
import org.gnome.gdk.Window;

final class GdkEvent extends Plumbing
{
    private GdkEvent() {}

    @SuppressWarnings("unused")
    static final FIXME getType(Event self) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final void setType(Event self, FIXME type) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final FIXME getAny(Event self) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final void setAny(Event self, FIXME any) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final FIXME getExpose(Event self) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final void setExpose(Event self, FIXME expose) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final FIXME getVisibility(Event self) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final void setVisibility(Event self, FIXME visibility) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final FIXME getMotion(Event self) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final void setMotion(Event self, FIXME motion) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final FIXME getButton(Event self) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final void setButton(Event self, FIXME button) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final FIXME getTouch(Event self) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final void setTouch(Event self, FIXME touch) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final FIXME getScroll(Event self) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final void setScroll(Event self, FIXME scroll) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final FIXME getKey(Event self) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final void setKey(Event self, FIXME key) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final FIXME getCrossing(Event self) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final void setCrossing(Event self, FIXME crossing) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final FIXME getFocusChange(Event self) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final void setFocusChange(Event self, FIXME focusChange) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final FIXME getConfigure(Event self) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final void setConfigure(Event self, FIXME configure) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final FIXME getProperty(Event self) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final void setProperty(Event self, FIXME property) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final FIXME getSelection(Event self) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final void setSelection(Event self, FIXME selection) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final FIXME getOwnerChange(Event self) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final void setOwnerChange(Event self, FIXME ownerChange) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final FIXME getProximity(Event self) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final void setProximity(Event self, FIXME proximity) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final FIXME getDnd(Event self) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final void setDnd(Event self, FIXME dnd) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final FIXME getWindowState(Event self) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final void setWindowState(Event self, FIXME windowState) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final FIXME getSetting(Event self) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final void setSetting(Event self, FIXME setting) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final FIXME getGrabBroken(Event self) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final void setGrabBroken(Event self, FIXME grabBroken) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final FIXME getTouchpadSwipe(Event self) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final void setTouchpadSwipe(Event self, FIXME touchpadSwipe) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final FIXME getTouchpadPinch(Event self) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final void setTouchpadPinch(Event self, FIXME touchpadPinch) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final FIXME getPadButton(Event self) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final void setPadButton(Event self, FIXME padButton) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final FIXME getPadAxis(Event self) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final void setPadAxis(Event self, FIXME padAxis) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final FIXME getPadGroupMode(Event self) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    @SuppressWarnings("unused")
    static final void setPadGroupMode(Event self, FIXME padGroupMode) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("Gdknull");
    }

    static final long createEvent(EventType type) {
        long result;

        if (type == null) {
            throw new IllegalArgumentException("type can't be null");
        }

        synchronized (lock) {
            result = gdk_event_new(numOf(type));

            return result;
        }
    }

    private static native final long gdk_event_new(int type);

    static final Event copy(Event self) {
        long result;

        if (self == null) {
            throw new IllegalArgumentException("self can't be null");
        }

        synchronized (lock) {
            result = gdk_event_copy(pointerOf(self));

            return (Event) boxedFor(Event.class, result);
        }
    }

    private static native final long gdk_event_copy(long self);

    static final void free(Event self) {
        if (self == null) {
            throw new IllegalArgumentException("self can't be null");
        }

        synchronized (lock) {
            gdk_event_free(pointerOf(self));
        }
    }

    private static native final void gdk_event_free(long self);

    static final boolean getAxis(Event self, AxisUse axisUse, double[] value) {
        boolean result;

        if (self == null) {
            throw new IllegalArgumentException("self can't be null");
        }

        if (axisUse == null) {
            throw new IllegalArgumentException("axisUse can't be null");
        }

        synchronized (lock) {
            result = gdk_event_get_axis(pointerOf(self), numOf(axisUse), value);

            return result;
        }
    }

    private static native final boolean gdk_event_get_axis(long self, int axisUse, double[] value);

    static final boolean getButton(Event self, int[] button) {
        boolean result;

        if (self == null) {
            throw new IllegalArgumentException("self can't be null");
        }

        synchronized (lock) {
            result = gdk_event_get_button(pointerOf(self), button);

            return result;
        }
    }

    private static native final boolean gdk_event_get_button(long self, int[] button);

    static final boolean getClickCount(Event self, int[] clickCount) {
        boolean result;

        if (self == null) {
            throw new IllegalArgumentException("self can't be null");
        }

        synchronized (lock) {
            result = gdk_event_get_click_count(pointerOf(self), clickCount);

            return result;
        }
    }

    private static native final boolean gdk_event_get_click_count(long self, int[] clickCount);

    static final boolean getCoords(Event self, double[] xWin, double[] yWin) {
        boolean result;

        if (self == null) {
            throw new IllegalArgumentException("self can't be null");
        }

        synchronized (lock) {
            result = gdk_event_get_coords(pointerOf(self), xWin, yWin);

            return result;
        }
    }

    private static native final boolean gdk_event_get_coords(long self, double[] xWin, double[] yWin);

    static final Device getDevice(Event self) {
        long result;

        if (self == null) {
            throw new IllegalArgumentException("self can't be null");
        }

        synchronized (lock) {
            result = gdk_event_get_device(pointerOf(self));

            return (Device) objectFor(result);
        }
    }

    private static native final long gdk_event_get_device(long self);

    @SuppressWarnings("unused")
    static final FIXME getDeviceTool(Event self) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("GdkDeviceTool*");
    }

    @SuppressWarnings("unused")
    static final FIXME getEventSequence(Event self) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("GdkEventSequence*");
    }

    static final EventType getEventType(Event self) {
        int result;

        if (self == null) {
            throw new IllegalArgumentException("self can't be null");
        }

        synchronized (lock) {
            result = gdk_event_get_event_type(pointerOf(self));

            return (EventType) enumFor(EventType.class, result);
        }
    }

    private static native final int gdk_event_get_event_type(long self);

    @SuppressWarnings("unused")
    static final boolean getKeycode(Event self, FIXME keycode) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("guint16*");
    }

    static final boolean getKeyval(Event self, int[] keyval) {
        boolean result;

        if (self == null) {
            throw new IllegalArgumentException("self can't be null");
        }

        synchronized (lock) {
            result = gdk_event_get_keyval(pointerOf(self), keyval);

            return result;
        }
    }

    private static native final boolean gdk_event_get_keyval(long self, int[] keyval);

    static final boolean getPointerEmulated(Event self) {
        boolean result;

        if (self == null) {
            throw new IllegalArgumentException("self can't be null");
        }

        synchronized (lock) {
            result = gdk_event_get_pointer_emulated(pointerOf(self));

            return result;
        }
    }

    private static native final boolean gdk_event_get_pointer_emulated(long self);

    static final boolean getRootCoords(Event self, double[] xRoot, double[] yRoot) {
        boolean result;

        if (self == null) {
            throw new IllegalArgumentException("self can't be null");
        }

        synchronized (lock) {
            result = gdk_event_get_root_coords(pointerOf(self), xRoot, yRoot);

            return result;
        }
    }

    private static native final boolean gdk_event_get_root_coords(long self, double[] xRoot, double[] yRoot);

    static final int getScancode(Event self) {
        int result;

        if (self == null) {
            throw new IllegalArgumentException("self can't be null");
        }

        synchronized (lock) {
            result = gdk_event_get_scancode(pointerOf(self));

            return result;
        }
    }

    private static native final int gdk_event_get_scancode(long self);

    static final Screen getScreen(Event self) {
        long result;

        if (self == null) {
            throw new IllegalArgumentException("self can't be null");
        }

        synchronized (lock) {
            result = gdk_event_get_screen(pointerOf(self));

            return (Screen) objectFor(result);
        }
    }

    private static native final long gdk_event_get_screen(long self);

    static final boolean getScrollDeltas(Event self, double[] deltaX, double[] deltaY) {
        boolean result;

        if (self == null) {
            throw new IllegalArgumentException("self can't be null");
        }

        synchronized (lock) {
            result = gdk_event_get_scroll_deltas(pointerOf(self), deltaX, deltaY);

            return result;
        }
    }

    private static native final boolean gdk_event_get_scroll_deltas(long self, double[] deltaX, double[] deltaY);

    static final boolean getScrollDirection(Event self, ScrollDirection[] direction) {
        boolean result;
        int[] _direction;

        if (self == null) {
            throw new IllegalArgumentException("self can't be null");
        }

        _direction = numsOf(direction);

        synchronized (lock) {
            result = gdk_event_get_scroll_direction(pointerOf(self), _direction);
            fillEnumArray(ScrollDirection.class, direction, _direction);

            return result;
        }
    }

    private static native final boolean gdk_event_get_scroll_direction(long self, int[] direction);

    @SuppressWarnings("unused")
    static final FIXME getSeat(Event self) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("GdkSeat*");
    }

    static final Device getSourceDevice(Event self) {
        long result;

        if (self == null) {
            throw new IllegalArgumentException("self can't be null");
        }

        synchronized (lock) {
            result = gdk_event_get_source_device(pointerOf(self));

            return (Device) objectFor(result);
        }
    }

    private static native final long gdk_event_get_source_device(long self);

    static final boolean getState(Event self, ModifierType[] state) {
        boolean result;
        int[] _state;

        if (self == null) {
            throw new IllegalArgumentException("self can't be null");
        }

        _state = numsOf(state);

        synchronized (lock) {
            result = gdk_event_get_state(pointerOf(self), _state);
            fillFlagArray(ModifierType.class, state, _state);

            return result;
        }
    }

    private static native final boolean gdk_event_get_state(long self, int[] state);

    static final int getTime(Event self) {
        int result;

        if (self == null) {
            throw new IllegalArgumentException("self can't be null");
        }

        synchronized (lock) {
            result = gdk_event_get_time(pointerOf(self));

            return result;
        }
    }

    private static native final int gdk_event_get_time(long self);

    static final Window getWindow(Event self) {
        long result;

        if (self == null) {
            throw new IllegalArgumentException("self can't be null");
        }

        synchronized (lock) {
            result = gdk_event_get_window(pointerOf(self));

            return (Window) objectFor(result);
        }
    }

    private static native final long gdk_event_get_window(long self);

    static final boolean isScrollStopEvent(Event self) {
        boolean result;

        if (self == null) {
            throw new IllegalArgumentException("self can't be null");
        }

        synchronized (lock) {
            result = gdk_event_is_scroll_stop_event(pointerOf(self));

            return result;
        }
    }

    private static native final boolean gdk_event_is_scroll_stop_event(long self);

    static final void put(Event self) {
        if (self == null) {
            throw new IllegalArgumentException("self can't be null");
        }

        synchronized (lock) {
            gdk_event_put(pointerOf(self));
        }
    }

    private static native final void gdk_event_put(long self);

    static final void setDevice(Event self, Device device) {
        if (self == null) {
            throw new IllegalArgumentException("self can't be null");
        }

        if (device == null) {
            throw new IllegalArgumentException("device can't be null");
        }

        synchronized (lock) {
            gdk_event_set_device(pointerOf(self), pointerOf(device));
        }
    }

    private static native final void gdk_event_set_device(long self, long device);

    @SuppressWarnings("unused")
    static final void setDeviceTool(Event self, FIXME tool) throws BlacklistedMethodError {
        throw new BlacklistedMethodError("GdkDeviceTool*");
    }

    static final void setScreen(Event self, Screen screen) {
        if (self == null) {
            throw new IllegalArgumentException("self can't be null");
        }

        if (screen == null) {
            throw new IllegalArgumentException("screen can't be null");
        }

        synchronized (lock) {
            gdk_event_set_screen(pointerOf(self), pointerOf(screen));
        }
    }

    private static native final void gdk_event_set_screen(long self, long screen);

    static final void setSourceDevice(Event self, Device device) {
        if (self == null) {
            throw new IllegalArgumentException("self can't be null");
        }

        if (device == null) {
            throw new IllegalArgumentException("device can't be null");
        }

        synchronized (lock) {
            gdk_event_set_source_device(pointerOf(self), pointerOf(device));
        }
    }

    private static native final void gdk_event_set_source_device(long self, long device);

    static final boolean triggersContextMenu(Event self) {
        boolean result;

        if (self == null) {
            throw new IllegalArgumentException("self can't be null");
        }

        synchronized (lock) {
            result = gdk_event_triggers_context_menu(pointerOf(self));

            return result;
        }
    }

    private static native final boolean gdk_event_triggers_context_menu(long self);
}

